import { ConnectButton } from '@rainbow-me/rainbowkit';
import Head from 'next/head';
import type { NextPage } from 'next'; 
import styles from '../styles/Home.module.css';
import { useReadContract, useWriteContract, useSignMessage } from 'wagmi'
import { type UseSignMessageReturnType } from 'wagmi'
import constants from '../../constants.json'
import { useState, useEffect, useRef } from 'react';
import { useAccount } from 'wagmi';
import { ethers } from "ethers";
import { toBytes } from 'viem';


const Home: NextPage = () => {
  const { writeContractAsync } = useWriteContract();
  const { signMessage } = useSignMessage();
  const { address: addressUser, isConnected } = useAccount();
  const [hasVoted, setHasVoted] = useState<boolean | null>(null);
  const [yesVotes, setYesVotes] = useState<string>('');
  const [hash, setHashVote] = useState<string>('');
  const [noVotes, setNoVotes] = useState<string>('');
  const [voteSignatureHash, setVoteSignatureHash] = useState<string>('');
  const hasProcessedHash = useRef(false);
  let hashTrx = '';

  const resultHasVoted = useReadContract({
    abi: constants.abi,
    address: constants.address as `0x${string}`,
    functionName: 'hasVoted',
    args: [addressUser], 
  });  
  
  useEffect(() => {
    if (resultHasVoted.data !== undefined) {
      setHasVoted(resultHasVoted.data as boolean | null);
    }
  }, [resultHasVoted]);

  const resultHatch = useReadContract({
    abi: constants.abi,
    address: constants.address as `0x${string}`,
    functionName: 'getVoteSignatureHash',
    args: [addressUser], 
  });  
  
  useEffect(() => {
      setHashVote(String(resultHatch.data));
  }, [resultHatch]);

  const resultNoVotes = useReadContract({
    abi: constants.abi,
    address: constants.address as `0x${string}`,
    functionName: 'getNoVotes',
  });

  useEffect(() => {
    console.log(resultNoVotes)
    setNoVotes(String(resultNoVotes.data))
  }, [resultNoVotes]);

  const voteSignaturesHash = useReadContract({
    abi: constants.abi,
    address: constants.address as `0x${string}`,
    functionName: 'voteSignatureHash',
  });

  useEffect(() => {
    console.log(voteSignaturesHash)
    setVoteSignatureHash(String(voteSignaturesHash.data))
  }, [voteSignaturesHash]);const resultYesVotes = useReadContract({
    abi: constants.abi,
    address: constants.address as `0x${string}`,
    functionName: 'getYesVotes',
  });
  
  useEffect(() => {
    if (resultYesVotes?.data) {
      const yesVotesData = String(resultYesVotes.data);
    } else {
      console.error('Error al obtener los votos: ', resultYesVotes?.error);
    }
    setYesVotes(String(resultYesVotes.data));
  }, [resultYesVotes]);
  
  return (
    <div className={styles.container}>
      <Head>
        <title>Voting Contract ðŸ’¼</title>
        <meta
          content="Generated by @rainbow-me/create-rainbowkit"
          name="description"
        />
        <link href="/favicon.ico" rel="icon" />
      </Head>

      <main className={styles.main}>
        
        <div style={{ textAlign: 'center' }}>
          Hola, direcciÃ³n {addressUser}
          <br/>, Bienvenido a Voting Contract ðŸ’¼<br/><br/>
        </div>
        
        <ConnectButton /><br/>
        {hasVoted === false ? (
          <div style={{ display: 'flex', justifyContent: 'center', gap: '10px' }}>
          <button 
            onClick={() => {
              const message = JSON.stringify({voted: true, signature: 'miFirmaDeVotoAFavor'});
              const signature = signMessage({message: message, account: addressUser});
              writeContractAsync({
              abi: constants.abi,
              address: constants.address as `0x${string}`,
              functionName: 'vote', args: [true, ethers.keccak256(toBytes(signature))]
              }).then((result) => {
                hashTrx = result;
                console.log('hashTrx', hashTrx);
              }).catch((error) => {
                console.error('Error al votar a favor:', error);
              });}} 
            style={{ backgroundColor: 'green', color: 'white', padding: '10px 20px', border: 'none', borderRadius: '5px', cursor: 'pointer', flex: 1 }}
            >
            Votar a favor
          </button>
          <button 
          onClick={() => {
            const message = JSON.stringify({ vote: false, signature: 'miFirmaDeVotoEnContra' });
            const signature = signMessage({message: message, account: addressUser});
            writeContractAsync({
              abi: constants.abi,
              address: constants.address as `0x${string}`,
              functionName: 'vote', args: [false, ethers.keccak256(toBytes(signature))] }).
              then((result) => {
                hashTrx = result;
                console.log('hashTrx', hashTrx);
              }).catch((error) => {
                console.error('Error al votar a favor:', error);
              });}}
            style={{ backgroundColor: 'red', color: 'white', padding: '10px 20px', border: 'none', borderRadius: '5px', cursor: 'pointer', flex: 1 }}
            >
            Votar en contra
          </button>
        </div>
        ) : ( 
            <div style={{ display: 'flex', justifyContent: 'center', gap: '10px', padding: '10px', backgroundColor: '#f0f0f0', borderRadius: '10px', marginTop: '20px' }}>
            <p style={{ color: '#333', fontSize: '18px', fontWeight: 'bold' }}>Usted ya ha votado</p>
            </div>
        )}
        {hashTrx !== '0x0000000000000000000000000000000000000000000000000000000000000000' && hashTrx && <p style={{ color: '#333', fontSize: '18px', fontWeight: 'bold' }}>Hash de la transacciÃ³n: {hashTrx}</p>
        }
        
        <h3>Total de Votos:</h3>
          <p>Votos a favor: {yesVotes?.toString()}</p>
          <p>Votos en contra: {noVotes?.toString()}</p>
      </main>
    </div>
  );
};

export default Home;
